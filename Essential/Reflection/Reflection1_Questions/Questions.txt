---------------------
0. Что такое Reflection?
	- Благодаря чему работает Reflection? Что он использует в своей работе?
	- Что позволяет делать Reflection?
	- Какие основные классы есть в Reflection?

	Reflection работает благодаря тому, что программа на языке C# компилируется в сборку, которая содержит метаданные, скомпилированный код и ресурсы.
Оперируя метаданными и скомпилированным кодом, программа может отслеживать и модифицировать собственную структуру и поведение во время выполнения.
	Reflection позволяет: перечислять члены типа, создавать новые экземпляры объекта, запускать на выполнения члены
объекта, извлекать информацию о типе, извлекать информацию о сборке, исследовать пользовательские атрибуты, примененные к типу, создавать и компилировать 
новые сборки.
	Основными классы Reflection:
TypeInfo, Type (используется часто, поэтому находится в System), Assembly, MethodInfo, MemberInfo, FieldInfo, PropertyInfo и другие.

---------------------
1. typeof(MyClass) возвращает все время один и тот же экземпляр, или каждый раз создается новый?
	Независимо от количества созданных экземпляров типа существует только один объект типа, связанный со всеми экземплярами.

---------------------
2. obj.GetType() возвращает все время один и тот же экземпляр, или каждый раз создается новый?
	Независимо от количества созданных экземпляров типа существует только один объект типа, связанный со всеми экземплярами.

---------------------
3. Как определить по типу, что он Generic?
	Имена обобщенных типов снабжаются суффиксами в виде символа ', за которым следует количество параметров типа.
Например, Dictionary'2
	Можно использоать свойство IsGenericType, которое говорит о том, что тип - generic.

---------------------
4. Напиши программу, которая находит все Generic типы в сборке (например, mscorlib) и выводит их на экран.

---------------------
5. Напиши программу, которая создает Generic тип по его строковому имени.
	- Имя Generic типа считывается из конфиг файла приложения.
		Например, key=”container” value=”System.Collections.Generic.List<System.Int32>”

---------------------
6. В чем отличие Assembly.CreateInstance() vs Activator.CreateInstance()?
	Отличие состоит в том, что первый метод создает экземпляр в данной сборке (Находит тип в этой сборке и создает его экземпляр, 
используя абстрактный метод.), а для второго можно указать сборку, а можно не указывать. Создает экземпляр указанного типа, используя конструктор, 
который наиболее полно соответствует указанным параметрам.

---------------------
7. Что такое Attribute?
	- Зачем их применяют?
	- Как сделать свой?
	- Как применить в коде?
	- Как получить информацию из атрибута во время выполнения программы? Что при этом используется?

	Attribute - языковая конструкция, которая позволяет добавлять метаданные в программную сборку. Это специальный класс для хранения информации о программе.
	Цель применения - сказать компилятору выделить определенный набор метаданных о программе и разместить их в сборке.
	Attribute применяются в [] и только для конструкции, следующей непосредственно после него.
	Существует два стандартных способа извлечения атрибутов во время выполнения:
		- вызов GetCustomAttributes на любом объекте Type или MemberInfo;
		- вызов Attribute.GetCustomAttribute или Attribute.GetCustomAttributes.
	Для получения информации об атрибутах можно также вызвать метод GetCustomAttributesData() на типе или члене.

---------------------
8. Как можно динамически добавить в существующий метод пару операций в Runtime?
	Добавить новую операцию в метод в Runtime можно с помощью System.Reflection.Emit.OpCodes.
Например, OpCodes.Ret, OpCodes.Call, OpCodes.Stfld и т.д.

---------------------
9. Как можно динамически добавить новый метод в существующий класс в Runtime?
	Добавить новый метод можно при вызове DefineMethod (можно указать возвращаемый тип и типы параметров),
или использовать DynamicMethod.

---------------------
10. Как можно динамически создать новый класс в Runtime?
	Т.к. тип должен находиться в модуле внутри сборки, необходимо сначала создать сборку и модуль (AssemblyBuilder).
Имея модуль и, в котором может находиться тип, можно воспользоваться классом TypeBuilder для создания типа.

---------------------
11. Как можно получить MSIL метода?
	Чтобы получить такой вывод, потребуется провести синтаксический разбор двоичных лексем, образующих IL.
Первый шаг состоит в вызове метода GetILAsByteArray на объекте MethodBody для получения IL в виде байтового массива.
Построив такой скелет, все, что нам остается - это написать метод DisassembleNextInstruction (используя OPCode из OpCodes).

---------------------
12. Как вызвать метод по строковому имени и передать в него список параметров в Runtime?
	Вызвать метод в Runtime можно с помощью объекта MethodInfo методом Invoke(object, object[]).
Первый параметр - инстанс, у котого вызывается метод, второй - параметры.

---------------------
13. Как внутри реализован тип dynamic? Во что разворачивается такой код? (рефлектор в помощь)
dynamic использует Reflection внутренне. Он кэширует выполненные вызовы методов, что в определенной степени повышает производительность.
Вывод .Net Reflector:
	object obj2 = 5;
    if (<>o__0.<>p__0 == null)
    {
        CSharpArgumentInfo[] infoArray1 = new CSharpArgumentInfo[] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.IsStaticType | CSharpArgumentInfoFlags.UseCompileTimeType, null), CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, null) };
        <>o__0.<>p__0 = CallSite<Action<CallSite, Type, object>>.Create(Binder.InvokeMember(CSharpBinderFlags.ResultDiscarded, "WriteLine", null, typeof(Program), infoArray1));
    }
    <>o__0.<>p__0.Target((CallSite) <>o__0.<>p__0, typeof(Console), obj2);

---------------------
14. В чем отличие Reflection от dynamic?
	dynamic - это ключевое слово, появившееся в .NET 4.0. Он оценивает вызовы объектов во время выполнения. Поэтому, пока 
не будут выполнены вызовы методов, компилятор будет меньше всего беспокоиться о том, существуют ли эти методы / свойства или нет.
dynamic использует Reflection внутренне. Он кэширует выполненные вызовы методов, что в определенной степени повышает производительность.
Отражение может вызывать как публичные, так и частные члены объекта, в то время как динамическое может вызывать только публичные члены.
dynamic зависит от экземпляра: у вас нет доступа к статическим членам; в этих сценариях вы должны использовать Reflection.

---------------------
15. Напиши класс wrapper (обертку), которая настраивается на некоторый объект определенного типа, но вызывает его методы через Reflection (2..3 операции).

---------------------
16. Как можно оптимизировать перечисление типов в сборке (ускорить)?
	Если нужно просто проверить информацию о типах (не создавая экземпляров и не обращаясь к членам типов),
то решение заключается в загрузке сборки в контекст, предназначенный только для рефлексии.
Assembly.ReflectionOnlyLoadFrom(string);

---------------------
17. Что такое раннее связывание?
	Обычно, когда мы говорим о «раннем связывании» мы имеем ввиду «связывание, выполняемое компилятором и результат связывания «зашивается» 
в сгенерированный код»; если связывание завершается неудачно, то программа не запускается, поскольку компилятор не может перейти к фазе генерации кода.

---------------------
18. Что такое позднее связывание?
	 Под «поздним связыванием» мы подразумеваем, что «некоторая часть связывания будет выполняться во время выполнения» и, таким образом, ошибки связывания проявятся только во время выполнения.

---------------------
19. Что такое таблица виртуальных методов?
	Таблица виртуальных методов (англ. virtual method table, VMT) — координирующая таблица или vtable — механизм, используемый в языках программирования для 
поддержки динамического соответствия (или метода позднего связывания).
Координирующая таблица объекта содержит адреса динамически связанных методов объекта. Метод вызывается при выборке адреса метода из таблицы. Координирующая 
таблица будет той же самой для всех объектов, принадлежащих тому же классу, поэтому допускается её совместное использование.
Обычно компилятор создает отдельную vtable для каждого класса. После создания объекта указатель на эту vtable, называемый виртуальный табличный указатель
или vpointer (также иногда называется vptr или vfptr), добавляется как скрытый член данного объекта (а зачастую как первый член). Компилятор также генерирует «скрытый» код в конструкторе каждого класса для инициализации vpointer'ов его объектов адресами соответствующей vtable.