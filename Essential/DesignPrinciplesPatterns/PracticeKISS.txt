В текстовом файле нужно привести для принципа проектирования KISS три (лучше больше) примера кода, 
которые были не корректны с точки зрения этого принципа.

  1) Пример с habr.com.
    Задача: При пересечении фигур необходимо заштриховать область их пересечения.

    Нарушение пирнципа:
   
    public interface IShape
    {
    }

    public class Circle : IShape
    {
    }

    public class Rectangle : IShape
    {
    }

    public class RoundedRectangle : IShape
    {
    }

    public class IntersectionFinder
    {
        public IShape FindIntersection(IShape shape, IShape shape2)
        {
            if (shape is Circle && shape2 is Rectangle)
                return FindIntersection(shape as Circle, shape2 as Rectangle);
            
            if (shape is Circle && shape2 is RoundedRectangle)
                return FindIntersection(shape as Circle, shape2 as RoundedRectangle);
            
            if (shape is RoundedRectangle && shape2 is Rectangle)
                return FindIntersection(shape as RoundedRectangle, shape2 as Rectangle);
            
            return FindIntersection(shape2, shape);
        }

        private IShape FindIntersection(Circle circle, Rectangle rectangle)
        {
            return new RoundedRectangle(); //также код мог бы вернуть Rectangle или Circle, в зависимости от их размеров. Но для простоты будем считать что метод всегда возвращает RoundedRectangle
        }

        private IShape FindIntersection(Circle circle, RoundedRectangle rounedeRectangle)
        {
            return new Circle();
        }

        private IShape FindIntersection(RoundedRectangle roundedRectanglerectangle, Rectangle rectangle)
        {
            return new Rectangle();
        }  
    }

   Исправление:

     public class Shape
    {
        public Shape FindIntersection(Shape shape)
        {
            var method = MethodFinder.Find(this.GetType(), "FindIntersection", shape.GetType());

            if (method != null)
            {
                return (Shape)method.Invoke(this, new[] { shape });
            }

            return shape.FindIntersection(this);
        }
    }

    public class Circle : Shape
    {
        [UsedImplicitly]
        private Shape FindIntersection(Rectangle rectangle)
        {
            return new RoundedRectangle();//также код мог бы вернуть Rectangle или Circle, в зависимости от их размеров. Но для простоты будем считать что метод всегда возвращает RoundedRectangle
        }

        [UsedImplicitly]
        private Shape FindIntersection(RoundedRectangle rounedeRectangle)
        {
            return new Circle();
        }
    }

    public class Rectangle : Shape
    {
        [UsedImplicitly]
        private Shape FindIntersection(RoundedRectangle roundedRectangle)
        {
            return new Rectangle();
        }
    }

    public class RoundedRectangle : Shape
    {
    }

    public static class MethodFinder
    {
        public static MethodInfo Find(Type classType, string functionName, Type parameterType)
        {
            return
                classType.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public)
                .FirstOrDefault(
                    x => x.Name == functionName
                    && x.GetParameters().Count() == 1 
                    && x.GetParameters().First().ParameterType == parameterType);
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Shape shape = new Rectangle();
            var shapeIntersection = shape.FindIntersection(new Circle());
            Console.WriteLine(shapeIntersection.GetType());
        }
    }

  2) Простой пример с днями недели:

    Нарушение принципа:
  
    public string GetWeekDay(int number)
    {
	switch (number)
	{
		case 1: return "Понедельник";
		case 2: return "Вторник";	
		case 3: return "Среда";
		case 4: return "Четверг"; 
		case 5: return "Пятница";
		case 6: return "Суббота"; 
		case 7: return "Воскресенье";
		default: return string.Empty;
	}
    }

   Исправленный вариант:

   public string GetWeekDay(int number)
   {
	if (number < 1 || number > 7)
	  return string.Empty;
	  
	string[] days = {"Понедельдник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота", "Воскресенье"};

	return days[number - 1];
   }