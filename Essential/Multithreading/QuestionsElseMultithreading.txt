1. Как определить, что стандартный класс/метод/свойство потокобезопасно или нет?
  Для того, чтобы определить, что стандартный класс/метод/свойство потокобезопасно или нет нужно искать в документации подтверждение 
  потокобезопасности («thread safety») или предупреждение о небезопасности использоваться в «условиях многопоточности».

2. Можно ли с "стандартными обобщёнными коллекциями" одновременно работать в разных потоках? Как это можно сделать?
  Можно. Для этого нужно применять блокировки или SyncPrimitives.

3. Какие есть стандартные потоко-безопасные коллекции? Когда их следует применять?
  - BlockingCollection<T>
  - ConcurrentDictionary<TKey,TValue>	
  - ConcurrentQueue<T>	
  - ConcurrentStack<T>	
  - ConcurrentBag<T>
  Есть несколько проблем со стандартными коллекциями, которые не являются потокобезопасными:
    - При добавлении двумя потоками в List<T> элемента в одно и то же время, один поток перезапишет значение другого потока.
    - Нельзя сделать перечисление в многопоточном списке, потому что другой поток может изменить спсок в любое время, сделав пречислитель
      недействительным. При установке блокирвки может возникнуть deadlock.
  Чтобы решить все эти проблемы, вам нужны поточно-ориентированные коллекции, обеспечивающие атомарные операции.

4. Как можно реализовать отложенную инициализацию в C#? 
  Отложенную реализацию можно реализовать с помощью Lazy<T>, ThreadLocal<T>, LazyInitializer следующими способами:
  - (
	lazyLargeObject = new Lazy<LargeObject>(InitLargeObject);
  );

  - (
	    ThreadLocal<string> ThreadName = new ThreadLocal<string>(() =>
            {
                return "Thread" + Thread.CurrentThread.ManagedThreadId;
            });

            Action action = () =>
            {
                bool repeat = ThreadName.IsValueCreated;

                Console.WriteLine("ThreadName = {0} {1}", ThreadName.Value, repeat ? "(repeat)" : "");
            };

            Parallel.Invoke(action, action, action, action, action, action, action, action);

            ThreadName.Dispose();
  );

  - (
	ExpensiveData dataToUse = LazyInitializer.EnsureInitialized(ref _data, ref _dataInitialized, ref _dataLock);  
  );

5. Приведите примеры с кодом реализации паттерна Singleton в C#.
  a. Чем они отличаются?
  b. Как корректно реализовать Singleton в многопоточных приложения на .NET?  Какие есть варианты?
  
  Пример однопоточной реализации:
    public sealed class Singleton
    {
    private static Singleton instance=null;

    private Singleton()
    {
    }

    public static Singleton Instance
    {
    get
    {
    if (instance==null)
    {
    instance = new Singleton();
    }
    return instance;
    }
    }
    }
  
  Пример многопоточной реализации:
    public sealed class Singleton
    {
    private static Singleton instance = null;
    private static readonly object padlock = new object();

    Singleton()
    {
    }

    public static Singleton Instance
    {
    get
    {
    if (instance == null)
    {
    lock (padlock)
    {
    if (instance == null)
    {
    instance = new Singleton();
    }
    }
    }
    return instance;
    }
    }
    }

  Отличаются тем, что в многопоточном приложении один поток может создать экземпляр класса раньше, чем второй. Для того, чтобы реализовать
  паттерн в таком приложении необходимо поставить блокировку на создание экземпляра класса одним потоком.

  Еще варианты:
  - Без блокировок:
    public sealed class Singleton
    {
    private static readonly Singleton instance = new Singleton();

    // Explicit static constructor to tell C# compiler
    // not to mark type as beforefieldinit
    static Singleton()
    {
    }

    private Singleton()
    {
    }

    public static Singleton Instance
    {
    get
    {
    return instance;
    }
    }
    }

  - Ленивая инициализация:
    public sealed class Singleton
    {
    private Singleton()
    {
    }

    public static Singleton Instance { get { return Nested.instance; } }

    private class Nested
    {
    // Explicit static constructor to tell C# compiler
    // not to mark type as beforefieldinit
    static Nested()
    {
    }

    internal static readonly Singleton instance = new Singleton();
    }
    }

  - using .NET 4's Lazy<T> type:
    public sealed class Singleton
    {
    private static readonly Lazy<Singleton>
        lazy =
        new Lazy<Singleton>
            (() => new Singleton());

            public static Singleton Instance { get { return lazy.Value; } }

            private Singleton()
            {
            }
            }

6. В чём отличая между Concurrency и Multi-threading?
    Concurrency - это когда две или более задачи могут запускаться, выполняться и завершаться в перекрывающиеся периоды времени.
  Например, многозадачность на одноядерной машине.

    Многопоточность - это один из способов реализации конкурентного исполнения путем выделения абстракции "рабочего потока" (worker thread).
  Потоки "абстрагируют" от пользователя низкоуровневые детали и позволяют выполнять более чем одну работу "параллельно". Операционная система, 
  среда исполнения или библиотека прячет подробности того, будет многопоточное исполнение конкурентным (когда потоков больше чем физических процессоров), 
  или параллельным (когда число потоков меньше или равно числу процессоров и несколько задач физически выполняются одновременно).

7. В чём отличая между Asynchronous и Multi-threading?
    Многопоточность - это один из способов реализации конкурентного исполнения путем выделения абстракции "рабочего потока" (worker thread).
  Потоки "абстрагируют" от пользователя низкоуровневые детали и позволяют выполнять более чем одну работу "параллельно". Операционная система, 
  среда исполнения или библиотека прячет подробности того, будет многопоточное исполнение конкурентным (когда потоков больше чем физических процессоров), 
  или параллельным (когда число потоков меньше или равно числу процессоров и несколько задач физически выполняются одновременно).

    Асинхронность (asynchrony) подразумевает, что операция может быть выполнена кем-то на стороне: удаленным веб-узлом, сервером или другим устройством за 
  пределами текущего вычислительного устройства. Основное свойство таких операций в том, что начало такой операции требует значительно меньшего времени, 
  чем основная работа. Что позволяет выполнять множество асинхронных операций одновременно даже на устройстве с небольшим числом вычислительных устройств.