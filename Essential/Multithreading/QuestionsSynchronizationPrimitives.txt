1. Что такое Thread?
  Поток - это базовая единица, которой операционная система выделяет процессорное время. Каждый поток имеет приоритет планирования и поддерживает 
набор структур, которые система использует для сохранения контекста потока, когда выполнение потока приостанавливается. Контекст потока включает 
всю информацию, необходимую потоку для беспрепятственного возобновления выполнения, включая набор регистров ЦП и стек потока.

2. Что такое Proccess?
  Процесс - это исполняемая программа. Операционная система использует процессы для разделения выполняемых приложений.

3. Что такое разделяемые данные?
  Разделяемые данные - данные общие для нескольких потоков.

4. Что такое lock()?
  Lock() - инструкция для исключающей блокировки потока. Только один поток может заблокировать синхронизирующий объект за раз, и любые конкурирующие 
потоки блокируются до тех пор, пока блокировка не будет снята. Если более одного поток оспаривает блокировку, они ставятся в очередь и получают 
блокировку в порядке живой очереди.

5. Как устроен lock()?
  Lock добавляет аргумент reference type выражения в некоторый список, который сведетельствует о том, что какой-то поток уже работает с общими данными.
Получая доступ к общим данным, поток смотрит, есть ли этот аргумент в данном списке. Если есть, то становится в очередь для доступа к общим данным.
Lock() является оберткой для следующего кода:
try
{
  System.Threading.Monitor.Enter();
}
finally
{
  System.Threading.Monitor.Exit();
}

6. Как разница между Mutex и Semaphore?
  Mutex можно использовать для предоставления монопольного доступа к ресурсу.
  Для Semaphore можно указать количество доступных потоков в данный момент и общее количество потоков.
Semaphore с емкостью 1 похож на Mutex, но не имеет владельца - не зависит от потока.

7. В каких случаях следует применять класс Interlocked?
  Методы этого класса помогают защититься от ошибок, которые могут возникать, когда планировщик переключает контексты, когда поток обновляет переменную, 
доступную для других потоков, или когда два потока одновременно выполняются на разных процессорах. Члены этого класса не создают исключения. Класс 
Interlocked позволяет создавать простые операторы для атомарных операций с переменными. Например, операция i++ не является безопасной в отношении потоков. 
Она подразумевает извлечение значения из памяти, увеличение этого значения на 1 и его обратное сохранение в памяти. Такие операции могут прерываться 
планировщиком потоков. Класс Interlocked предоставляет методы, позволяющие выполнять инкремент, декремент, обмен и считывание значений в безопасной к 
потокам манере.

8. В чём преимущество SpinLock?
  Предоставляет примитив взаимно исключающей блокировки, в котором поток, пытающийся получить блокировку, ожидает в состоянии цикла, проверяя доступность 
блокировки. Спин-блокировки можно использовать для блокировок конечного уровня, где выделение объектов, подразумеваемое с помощью Monitor , в размере или 
из-за нажима на сборку мусора, слишком дорого. Спин-блокировка может быть полезна во избежание блокировки.

9. Что такое состояние гонки? Почему это происходит?
  Состояние гонки (англ. race condition), также конкуренция — ошибка проектирования многопоточной системы или 
приложения, при которой работа системы или приложения зависит от того, в каком порядке выполняются части кода. 
Своё название ошибка получила от похожей ошибки проектирования электронных схем (см. Гонки сигналов).
  Термин состояние гонки относится к инженерному жаргону и появился вследствие неаккуратного дословного перевода 
английского эквивалента. В более строгой академической среде принято использовать термин неопределённость 
параллелизма.
  Состояние гонки — «плавающая» ошибка (гейзенбаг), проявляющаяся в случайные моменты времени и «пропадающая» 
при попытке её локализовать.
  Если два или более потока совместно используют объект и более одного потока обновляют переменные в этом 
общем объекте, могут возникнуть условия гонки.
  Представьте, что поток A считывает счетчик переменных общего объекта в свой кэш ЦП. Представьте также, 
что поток B делает то же самое, но в другой кэш ЦП. Теперь поток A добавляет единицу для подсчета, и поток 
B делает то же самое. Теперь var1 был увеличен дважды, по одному разу в каждом кэше ЦП.
  Если бы эти приращения выполнялись последовательно, счетчик переменных был бы увеличен дважды, и исходное 
значение + 2 было бы записано обратно в основную память.
  Однако два приращения были выполнены одновременно без надлежащей синхронизации. Независимо от того, какой 
из потоков A и B записывает свою обновленную версию счетчика обратно в основную память, обновленное значение 
будет только на 1 выше исходного значения, несмотря на два приращения.

10. Что такое DeadLock? В чём причина? Как исправлять?
  Взаи́мная блокиро́вка (сокращённо взаимоблокировка, англ. deadlock) — ситуация в многозадачной среде или СУБД, 
при которой несколько процессов находятся в состоянии ожидания ресурсов, занятых друг другом, и ни один из них 
не может продолжать свое выполнение.
  Взаи́мная блокиро́вка - это когда два или более потока заблокированы в ожидании получения блокировок, 
которые удерживают другие потоки в тупике. Взаимоблокировка может возникнуть, когда нескольким потокам требуются 
одинаковые блокировки одновременно, но они получают их в разном порядке.
  Например, если поток 1 блокирует A и пытается заблокировать B, а поток 2 уже заблокировал B и пытается 
заблокировать A, возникает взаимоблокировка. Поток 1 никогда не получит B, а поток 2 никогда не получит A. 
Кроме того, ни один из них никогда не узнает. Они навсегда останутся заблокированными для каждого своего объекта, 
A и B. Это тупиковая ситуация.
  Если вы убедитесь, что все блокировки всегда выполняются в одном и том же порядке любым потоком, взаимоблокировки 
не могут возникнуть.
  Другой механизм предотвращения взаимоблокировок - установить тайм-аут для попыток блокировки, что означает, 
что поток, пытающийся получить блокировку, будет пытаться только так долго, прежде чем отказаться. Если потоку 
не удается взять все необходимые блокировки в течение заданного тайм-аута, он выполняет резервное копирование, 
освобождает все взятые блокировки, ожидает произвольное время и затем повторяет попытку. Случайное количество 
времени ожидания служит для того, чтобы дать другим потокам, пытающимся воспользоваться теми же блокировками, 
шанс снять все блокировки и, таким образом, позволить приложению продолжить работу без блокировок.

11. Что такое volatile? Когда его следует применять?
  Ключевое слово volatile означает, что поле может изменить несколько потоков, выполняемых одновременно. Компилятор, среда выполнения или даже 
аппаратное обеспечение могут изменять порядок операций чтения и записи в расположения в памяти для повышения производительности. К полям, которые 
объявлены как volatile, такие оптимизации не применяются. Добавление модификатора volatile гарантирует, что все потоки будут видеть временные 
записи, выполняемые другим потоком, в порядке их выполнения. Ключевое слово volatile можно применять только к полям class или struct. Локальные 
переменные не могут объявляться как volatile.

12. В чём особенность статического конструктора? Чем это полезно?
  Статический конструктор типа вызывается только один раз при первом обращении к какому-либо члену типа либо перед вызовом экземплярного конструктора.
  Это может быть полезно при инициализации, т.к. будет гарантированно, что статический конструктор вызовится единожды в домене приложения.
Можно присвоить знанчения статическим полям один раз даже при том, что несколько потоков будет создавать новый экземпяр типа.

13.Можно ли применять метод  Thread.Abort()?  Почему? Как следует завершать выполнение потоков?
  Вызывает исключение ThreadAbortException в вызвавшем его потоке для того, чтобы начать процесс завершения потока. 
Вызов данного метода обычно завершает поток.
  Когда поток вызывает Abort сам себя, этот результат аналогичен созданию исключения; ThreadAbortException происходит 
немедленно, и результат является прогнозируемым. Однако если один поток вызывает Abort другой поток, прерывание прерывает 
выполнение любого кода. Существует также вероятность прерывания статического конструктора. В редких случаях это может 
препятствовать созданию экземпляров этого класса в этом домене приложения. В .NET Framework версиях 1,0 и 1,1 существует 
шанс, что поток может прерваться во время finally выполнения блока, в этом случае finally блок будет прерван.
  Выполнения потоков можно завершать вызовом Threading.Interrupt().
  
14. Можно ли применять методы Thread.Suspend() и Thread.Resume()? Почему? Что следует использовать вместо этих методов?
  Не используйте Suspend Resume методы и для синхронизации действий потоков. У вас нет способа узнать, какой код выполняется потоком при его 
приостановке. Если приостановить поток, который удерживает блокировки во время оценки разрешений безопасности, другие потоки в AppDomain могут 
быть заблокированы. Если приостановить поток во время выполнения конструктора класса, то другие потоки в этой AppDomain попытке использовать 
этот класс блокируются. Взаимоблокировки могут происходить очень легко.
  Следует использовать другие классы в System.Threading, такие как Monitor, Mutex, Event и Semaphore, для синхронизации потоков или защиты ресурсов.

15. Что такое WaitHandle? Что такое EventWaitHandle? Чем отличаются?
  WaitHandleКласс инкапсулирует собственный обработчик синхронизации операционной системы и используется для представления всех объектов синхронизации 
в среде выполнения, которые допускают несколько операций ожидания. WaitHandle класс является абстрактным. Классы, производные от WaitHandle , определяют 
механизм сигнализации, указывающий на получение или освобождение доступа к общему ресурсу, но они используют унаследованные WaitHandle методы для блокировки 
при ожидании доступа к общим ресурсам. 
  EventWaitHandle представляет событие синхронизации потока. EventWaitHandle позволяет потокам взаимодействовать друг с другом посредством сигнализации. 
Как правило, один или несколько потоков блокируют в EventWaitHandle до тех пор, пока незаблокированный поток не вызовет Set метод, освобождая один или 
несколько заблокированных потоков.

16. Что такое AutoResetEvent? Что такое ManualResetEvent? Чем отличаются?
  AutoResetEvent представляет событие синхронизации потоков, которое при срабатывании автоматически сбрасывается, освобождая один поток в состоянии 
ожидания.
  ManualResetEvent представляет событие синхронизации потока, которое при получении сигнала необходимо сбросить вручную.