1. Что такое Task?
    Task класс описывает отдельную задачу, которая запускается асинхронно в одном из потоков из пула потоков. 
  Хотя ее также можно запускать синхронно в текущем потоке.

2. Чем Task отличается от Thread?
    Thread представляет собой реальный поток уровня ОС со своим собственным стеком и ресурсами ядра. Thread обеспечивает высочайшую степень контроля.
  Вы можете Abort (), Suspend () или Resume () поток (хотя это очень плохая идея), вы можете наблюдать за его состоянием и вы можете установить 
  свойства уровня потока, такие как размер стека.

    По сравнению с потоком Task - абстракция более высокого уровня - она ​​представляет собой параллельную операцию, которая могла бы или могла бы не 
  подкрепляться потоком. Задачи композиционные (их можно объединить в цепочку). Они могут использовать пул потоков, чтобы уменьшить задержку при запуске, 
  а с TaskCompletionSource они могут использовать подход обратного вызова, что позволяет полностью избежать потоков во время ожидания операций, 
  связанных с вводом-выводом.

3. Какие есть способы создать и запустить Task?
  Для определения и запуска задачи можно использовать различные способы. 
  
    Первый способ создание объекта Task и вызов у него метода Start:
  Task task = new Task(() => Console.WriteLine("Hello Task!"));
  task.Start();

    Второй способ заключается в использовании статического метода Task.Factory.StartNew(). Этот метод также в качестве параметра принимает делегат Action, 
  который указывает, какое действие будет выполняться. При этом этот метод сразу же запускает задачу:
  Task task = Task.Factory.StartNew(() => Console.WriteLine("Hello Task!"));

    Третий способ определения и запуска задач представляет использование статического метода Task.Run(): 	
  Task task = Task.Run(() => Console.WriteLine("Hello Task!"));

4. На каком потоке будет выполняться запущенный Task?
  Для выполнения Task будет назначен поток из ThreadPool внутри Task.

5. Как можно запустить Task на "отдельном потоке"? Когда это необходимо делать?
    Для длительных и блокирующих операций, вы можете предотвратить использование пула потоков следующим образом:
  Task task = Task.Factory.StartNew (() => ..., TaskCreationOptions.LongRunning);

6. Как можно выполнить действия в "продолжении" выполненного Task?
    Продолжение обычно реализуется обратным вызовом, который выполняется один раз после завершение операции. Есть два способа прикрепить продолжение 
  к задаче.

  Первый способ:
  Task<int> primeNumberTask = Task.Run (() =>
    Enumerable.Range (2, 3000000).Count (n =>
    Enumerable.Range (2, (int)Math.Sqrt(n)-1).All (i => n % i > 0)));
    var awaiter = primeNumberTask.GetAwaiter();
  awaiter.OnCompleted (() =>
  {
     int result = awaiter.GetResult();
     Console.WriteLine (result); // Writes result
  });

    Вызов GetAwaiter для задачи возвращает объект ожидания, у которого OnCompleted сообщает предыдущей задаче (primeNumberTask) выполнить делегат, 
  когда он завершится. 

  Второй способ:
  primeNumberTask.ContinueWith (antecedent =>
  {
     int result = antecedent.Result;
     Console.WriteLine (result); // Writes 123
  });

  ContinueWith сам возвращает Task, что полезно, если вы хотите прикрепить дальше для продолжения.

7. Зачем нужны Concurrent Collection? Какие есть Concurrent Collection?
    Классы коллекций в пространстве имен System.Collections.Concurrent обеспечивают потокобезопасные операции добавления и удаления, которые избегают 
  блокировок везде, где это возможно, и используют детализированную блокировку там, где блокировки необходимы.
  
  System.Collections.Concurrent.BlockingCollection<T> - Предоставляет возможности блокировки и ограничения для поточно-ориентированных коллекций, 
    реализующих System.Collections.Concurrent.IProducerConsumerCollection <T>. Потоки производителя блокируются, если нет доступных слотов или если 
    коллекция заполнена. Потребительские потоки блокируются, если коллекция пуста. Этот тип также поддерживает неблокирующий доступ потребителей и 
    производителей. BlockingCollection <T> может использоваться как базовый класс или резервное хранилище для обеспечения блокировки и ограничения 
    для любого класса коллекции, поддерживающего IEnumerable <T>.

  System.Collections.Concurrent.ConcurrentBag<T> - Поточно-ориентированная реализация пакета, обеспечивающая масштабируемые операции добавления и 
    получения.

  System.Collections.Concurrent.ConcurrentDictionary<TKey,TValue> - Параллельный и масштабируемый тип словаря.

  System.Collections.Concurrent.ConcurrentQueue<T> - Параллельная и масштабируемая очередь FIFO.

  System.Collections.Concurrent.ConcurrentStack<T> - Параллельный и масштабируемый стек LIFO.