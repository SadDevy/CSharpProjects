1) Для каждого варианта указать работает или нет. И почему работает или нет.
  1. int zero = 0, то есть lock(zero){…}
    Compile Error - Lock принимает переменную reference type.
  2. lock (zero.GetType()) { }
    Работает, но использовать не рекомендуется, т.к. создается один 
    экземпляр для всего процесса.
  3. lock (typeof(int)) { }
    Работает, но использовать не рекомендуется, т.к. создается один 
    экземпляр для всего процесса.
  4. lock(“Hello”){…}
    Работает, но использовать не рекомендуется, т.к. литералы строк могут 
    быть интернированы, т.е. одинаковые строковые литералы в памяти хранятся 
    как один экземпляр.
  5. class A{}; A a = new A(); lock(a){}
    Работает, если используется один locker для одного ресурса.
    Если каждый поток будет создавать свой экземпляр locker, то блокировка
    работать не будет.
  6. lock(this){}
    Работает, но использовать не рекомендуется, т.к. так как он может 
    использоваться вызывающими объектами как блокировка.
  7. object x; lock(x){}
    Работает, если используется один locker для одного ресурса.
    Если каждый поток будет создавать свой экземпляр locker, то блокировка
    работать не будет.
  8. lock (typeof(object)) { }
    Работает, но использовать не рекомендуется, т.к. создается один 
    экземпляр для всего процесса.
  9. массив int
    Работает, если используется один locker для одного ресурса.
    Если каждый поток будет создавать свой экземпляр locker, то блокировка
    работать не будет.
  10. обобщённый список int
    Работает, если используется один locker для одного ресурса.
    Если каждый поток будет создавать свой экземпляр locker, то блокировка
    работать не будет.

2) Указать наиболее правильный способ и почему нужно использовать именно его.
  object x = new object; lock(x){}
  Является наиболее правильным, если не будет использоваться как объект
  блокировки другими частями кода.

3) Указать во что превращается lock(){} после компиляции.
  После компиляции lock(){} превращается в блок try{ System.Threading.Monitor.Enter(_, ref _); }finally{ if (_) System.Threading.Monitor.Exit(_); }